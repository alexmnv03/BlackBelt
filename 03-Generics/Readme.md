# Generics

Суть примера - у нас есть команды школьников, студентов и работников. Две команды могут играть друг с другом, но только в пределах своей группы студенты со студентами и т.д.
На примере GameTest мы видим, что добавление просто дженерика в класс Team вызывает проблему - мы можем создать объект класса с любым типом, например String, а нам это не нужно, поэтому мы должны ограничить только типами наследуемыми от Participant <T extends Participant>

Но у нас остается еще одна проблема, нет ограничений по группам, школьники могут играть с работниками и т.д.
Чтобы это исправить добавим в метод playWith ограничение, что мы можем играть только с той командой в которой мы находимся сами Team<T>

<?> любой класс, в этом случае любой символ класса который мы указали в качестве дженерика (T, K, V , ...) после компиляции будет заменен классом Object

<? extends X> класс X или любой его сабкласс, т.е. ? должен быть наследником X, т.е. extends класс X
, в этом случае любой символ класса который мы указали в качестве дженерика (T, K, V , ...) после компиляции будет заменен классом X

О джененриках знает только компилятор, а в рантайме вся информация о них удаляется
т.е. JVM вот эту запись
```ArrayList<Integer> list = new ArrayList<>();```
видит вот так
```ArrayList list = new ArrayList();```
т.е. в классе ErasureTest мы не можем создать два метода
```
    public void abc(InfoErasure<String> info) {
        String str = info.getValue();
    }
    
    public void abc(InfoErasure<Integer> info) {
        Integer i = info.getValue();
    }
```
т.к. они будут выглядеть одинаково
Так же мы не можем реализовать это с помощью наследования, см. Parent и ChildParent


Стирание типов - для обратной совместимости
<? super Y> класс Y или любой его супер класс, т.е. ? должен быть предком Y, т.е. классы выше по иерархии, например Object относительно Number
```
List<? super Number> list6 = new ArrayList<Object>();
```