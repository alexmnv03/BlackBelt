#  Коллекции для работы с многопоточностью

До этого мы рассматривали не потокобезопасные коллекции

> Потокобезопасные коллекции более медленне, т.к. им надо следить за потоками

Существует два вида таких коллекций
1. Synchronized Collection - получаются из обычных благодаря их обертыванию
2. Concurent - изнчально созданы для работы с коллекциями


## Synchronized Collection 

Collections -предотавляет обертки, которые позовляют получить из обычной колеекции потокобезопасную

Collections.Synchronized
Эти коллекции используют Lock для всех методов, поэтому они сильно уступают в произхводительности по сравнению Concurent

В классе SynchronizedCollectionTest у нас может получиться не предсказуемый результат, тут это не видно из маленкого обтьема
Перепишем наш класс - SynchronizedCollectionSyncTest
Теперь код работает по другому, когда первый поток начал работу с списком, доступ другим потоком к этому списку будет закрыт пока он не прекратит работу, и тольк отогда со списком начнет работать второй поток

Рассмотрим другой пример SynchronizedCollectionTwoTest - тут мы видим что выетает ошибка, т.к. при обхзоде листа другой поток пытается удалить из него элементы

Изменим нашщ класс на SynchronizedCollectionTwoSyncTest
Но несмотря на то, что мы используем потокобезопасную коллекцию, мы все равно в некоторых слчаях получаем ConcurrentModificationException
Это происходит потому что использование Iterator не безопасно в многопоточке, чтобы это испоравить необходимо поместить этот код в блок synchronized(syncList)
см. SynchronizedCollectionTwoSinxroTest
Вот только теперь мы не получим ошибки

Почему так получилось, когда начался обход итератором коллекции и тут с колелкуией начал работать другой поток, который может удалить элементы или добавить новые и что делать итературу? Может в коллекции уже нет элементов или их стало больше. Чтобы избежать коллизий он выбрасывает ошибку.




